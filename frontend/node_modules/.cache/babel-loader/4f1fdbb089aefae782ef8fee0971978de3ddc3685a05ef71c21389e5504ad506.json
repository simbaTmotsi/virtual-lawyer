{"ast":null,"code":"var _jsxFileName = \"/Users/simbatmotsi/Documents/Projects/virtual-lawyer/frontend/src/contexts/NotificationsContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { useState, useEffect } from 'react';\nimport { api } from '../utils/api';\n\n// Create context\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst NotificationsContext = /*#__PURE__*/React.createContext(null);\nconst NotificationsProvider = ({\n  children\n}) => {\n  _s();\n  const [notifications, setNotifications] = useState([]);\n  const [unreadCount, setUnreadCount] = useState(0);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const fetchNotifications = async () => {\n    try {\n      setLoading(true);\n\n      // First check authentication status using the public endpoint\n      const statusResponse = await api.get('/api/notifications/status/');\n\n      // Only fetch notifications if the user is authenticated\n      if (statusResponse.data && statusResponse.data.authenticated) {\n        const response = await api.get('/api/notifications/');\n        const notificationData = response.data || [];\n        // Ensure notificationData is an array before using filter\n        const notificationsArray = Array.isArray(notificationData) ? notificationData : [];\n        setNotifications(notificationsArray);\n        setUnreadCount(notificationsArray.filter(notification => !notification.read).length);\n      } else {\n        var _statusResponse$data;\n        // User is not authenticated, just update unread count from status\n        setUnreadCount(((_statusResponse$data = statusResponse.data) === null || _statusResponse$data === void 0 ? void 0 : _statusResponse$data.unread_count) || 0);\n        setNotifications([]);\n      }\n      setError(null);\n    } catch (err) {\n      console.error('Failed to fetch notifications:', err);\n      setNotifications([]);\n      setUnreadCount(0);\n      setError('Failed to load notifications');\n    } finally {\n      setLoading(false);\n    }\n  };\n  const markAsRead = async notificationId => {\n    try {\n      await api.patch(`/api/notifications/${notificationId}/`, {\n        read: true\n      });\n\n      // Update local state\n      setNotifications(notifications.map(notification => notification.id === notificationId ? {\n        ...notification,\n        read: true\n      } : notification));\n      setUnreadCount(prev => Math.max(0, prev - 1));\n      return true;\n    } catch (err) {\n      console.error('Failed to mark notification as read:', err);\n      return false;\n    }\n  };\n  const markAllAsRead = async () => {\n    try {\n      await api.post('/api/notifications/mark-all-read/');\n\n      // Update local state\n      setNotifications(notifications.map(notification => ({\n        ...notification,\n        read: true\n      })));\n      setUnreadCount(0);\n      return true;\n    } catch (err) {\n      console.error('Failed to mark all notifications as read:', err);\n      return false;\n    }\n  };\n\n  // Fetch notifications when the component mounts and set up polling\n  useEffect(() => {\n    // Initial fetch\n    fetchNotifications();\n\n    // Set up polling for new notifications (every 2 minutes)\n    const intervalId = setInterval(fetchNotifications, 120000); // Increased from 60s to 120s to reduce server load\n\n    return () => clearInterval(intervalId);\n  }, []);\n  return /*#__PURE__*/_jsxDEV(NotificationsContext.Provider, {\n    value: {\n      notifications,\n      unreadCount,\n      loading,\n      error,\n      fetchNotifications,\n      markAsRead,\n      markAllAsRead\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 90,\n    columnNumber: 5\n  }, this);\n};\n\n// Hook for using the notifications context\n_s(NotificationsProvider, \"luGxckMMpZuJ/EnbdxvGERjh3AQ=\");\n_c = NotificationsProvider;\nexport const useNotifications = () => {\n  _s2();\n  const context = React.useContext(NotificationsContext);\n  if (!context) {\n    throw new Error('useNotifications must be used within a NotificationsProvider');\n  }\n  return context;\n};\n_s2(useNotifications, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nexport default NotificationsProvider;\nvar _c;\n$RefreshReg$(_c, \"NotificationsProvider\");","map":{"version":3,"names":["React","useState","useEffect","api","jsxDEV","_jsxDEV","NotificationsContext","createContext","NotificationsProvider","children","_s","notifications","setNotifications","unreadCount","setUnreadCount","loading","setLoading","error","setError","fetchNotifications","statusResponse","get","data","authenticated","response","notificationData","notificationsArray","Array","isArray","filter","notification","read","length","_statusResponse$data","unread_count","err","console","markAsRead","notificationId","patch","map","id","prev","Math","max","markAllAsRead","post","intervalId","setInterval","clearInterval","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useNotifications","_s2","context","useContext","Error","$RefreshReg$"],"sources":["/Users/simbatmotsi/Documents/Projects/virtual-lawyer/frontend/src/contexts/NotificationsContext.js"],"sourcesContent":["import React, { useState, useEffect } from 'react';\nimport { api } from '../utils/api';\n\n// Create context\nconst NotificationsContext = React.createContext(null);\n\nconst NotificationsProvider = ({ children }) => {\n  const [notifications, setNotifications] = useState([]);\n  const [unreadCount, setUnreadCount] = useState(0);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  const fetchNotifications = async () => {\n    try {\n      setLoading(true);\n      \n      // First check authentication status using the public endpoint\n      const statusResponse = await api.get('/api/notifications/status/');\n      \n      // Only fetch notifications if the user is authenticated\n      if (statusResponse.data && statusResponse.data.authenticated) {\n        const response = await api.get('/api/notifications/');\n        const notificationData = response.data || [];\n        // Ensure notificationData is an array before using filter\n        const notificationsArray = Array.isArray(notificationData) ? notificationData : [];\n        setNotifications(notificationsArray);\n        setUnreadCount(notificationsArray.filter(notification => !notification.read).length);\n      } else {\n        // User is not authenticated, just update unread count from status\n        setUnreadCount(statusResponse.data?.unread_count || 0);\n        setNotifications([]);\n      }\n      \n      setError(null);\n    } catch (err) {\n      console.error('Failed to fetch notifications:', err);\n      setNotifications([]);\n      setUnreadCount(0);\n      setError('Failed to load notifications');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const markAsRead = async (notificationId) => {\n    try {\n      await api.patch(`/api/notifications/${notificationId}/`, { read: true });\n      \n      // Update local state\n      setNotifications(notifications.map(notification => \n        notification.id === notificationId \n          ? { ...notification, read: true } \n          : notification\n      ));\n      \n      setUnreadCount(prev => Math.max(0, prev - 1));\n      return true;\n    } catch (err) {\n      console.error('Failed to mark notification as read:', err);\n      return false;\n    }\n  };\n\n  const markAllAsRead = async () => {\n    try {\n      await api.post('/api/notifications/mark-all-read/');\n      \n      // Update local state\n      setNotifications(notifications.map(notification => ({ ...notification, read: true })));\n      setUnreadCount(0);\n      return true;\n    } catch (err) {\n      console.error('Failed to mark all notifications as read:', err);\n      return false;\n    }\n  };\n\n  // Fetch notifications when the component mounts and set up polling\n  useEffect(() => {\n    // Initial fetch\n    fetchNotifications();\n    \n    // Set up polling for new notifications (every 2 minutes)\n    const intervalId = setInterval(fetchNotifications, 120000); // Increased from 60s to 120s to reduce server load\n    \n    return () => clearInterval(intervalId);\n  }, []);\n\n  return (\n    <NotificationsContext.Provider \n      value={{ \n        notifications, \n        unreadCount, \n        loading, \n        error, \n        fetchNotifications, \n        markAsRead, \n        markAllAsRead \n      }}\n    >\n      {children}\n    </NotificationsContext.Provider>\n  );\n};\n\n// Hook for using the notifications context\nexport const useNotifications = () => {\n  const context = React.useContext(NotificationsContext);\n  if (!context) {\n    throw new Error('useNotifications must be used within a NotificationsProvider');\n  }\n  return context;\n};\n\nexport default NotificationsProvider;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}